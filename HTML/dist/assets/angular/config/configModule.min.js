angular
  .module("appToten")
  .factory("loadingInterceptor", loadingInterceptor);

loadingInterceptor.$inject = ['$q', '$rootScope'];

function loadingInterceptor($q, $rootScope) {
  var loadingCount = 0;
  return {
    request: function (config) {
      if (++loadingCount === 1) $rootScope.$broadcast('loading:progress');
      return config || $q.when(config);
    },

    response: function (response) {
      if (--loadingCount === 0) $rootScope.$broadcast('loading:finish');
      return response || $q.when(response);
    },

    responseError: function (response) {
      if (--loadingCount === 0) $rootScope.$broadcast('loading:finish');
      return $q.reject(response);
    }
  };
};
angular
  .module("appToten")
  .factory("autenticacaoInterceptor", [
    'localStorageService', 'config', 'base64Factory', '$location', function (localStorageService, config, base64Factory, $location) {
      return {
        request: function (requisicao) {

          try {
            var storage = localStorageService.get('auth');

            if (
              storage == null || requisicao.url.indexOf('.html') > -1
            ) {
              throw "Invalid"
            }

            var autorizacaoDados = JSON.parse(base64Factory.decode(storage));

            if (autorizacaoDados) {
              if (requisicao.url.indexOf("api") > -1 && requisicao.url.indexOf('oauth') == -1) {
                requisicao.headers["Authorization"] = "Bearer " + autorizacaoDados.access_token;
              }
            }

            return requisicao;
          }
          catch (e) {
            if (requisicao.url.indexOf("apigopharma") == -1) {
              return requisicao;
            }
          }

        }
      }
    }
  ]);

(function (angular) {
  angular
    .module("appToten")
    .config([
              '$httpProvider',
              function ($httpProvider) {
                $httpProvider.interceptors.push("autenticacaoInterceptor");
                $httpProvider.interceptors.push("loadingInterceptor");
              }
            ]);
})(angular);


angular
  .module("appToten")
  .constant("config", {
    "baseUrl": "https://lojadalucy.com.br/",
    "apiToken": "https://lojadalucy.com.br/oauth/token",
    "apiUrl": "https://lojadalucy.com.br/api/",
    "baseUrlDev": "http://toten.localhost/",
    "apiTokenDev": "http://toten.localhost/oauth/token",
    "apiUrlDev": "http://toten.localhost/api/",
    "grant_type": "password",
    "client_id": 3,
    "client_secret": "aw8AFIdfQ280GTnGjnJGHJGRc6lZpop1Pz3xhOj3",
    "client_secret_dev": "N8bENBm0tCa2KToFezvaL2Ms8zNw2XNh00VU0fJG",
    "scope": "*",
    "dev": false
  });


angular
  .module("appToten")
  .config([
            "$provide",
            function ($provide) {
              $provide.decorator("$q",
                                 [
                                   "$delegate",
                                   function ($delegate) {
                                     //Helper method copied from q.js.
                                     var isPromiseLike = function (obj) { return obj && angular.isFunction(obj.then); }

                                     /*
                                      * @description Execute a collection of tasks serially.  A task is a function that returns a promise
                                      *
                                      * @param {Array.<Function>|Object.<Function>} tasks An array or hash of tasks.  A tasks is a function
                                      *   that returns a promise.  You can also provide a collection of objects with a success tasks, failure task, and/or notify function
                                      * @returns {Promise} Returns a single promise that will be resolved or rejected when the last task
                                      *   has been resolved or rejected.
                                      */
                                     function serial(tasks) {
                                       //Fake a "previous task" for our initial iteration
                                       var prevPromise;
                                       var error = new Error();
                                       angular.forEach(tasks, function (task, key) {
                                         var success = task.success || task;
                                         var fail = task.fail;
                                         var notify = task.notify;
                                         var nextPromise;

                                         //First task
                                         if (!prevPromise) {
                                           nextPromise = success();
                                           if (!isPromiseLike(nextPromise)) {
                                             error.message = "Task " + key + " did not return a promise.";
                                             throw error;
                                           }
                                         } else {
                                           //Wait until the previous promise has resolved or rejected to execute the next task
                                           nextPromise = prevPromise.then(
                                             /*success*/function (data) {
                                               if (!success) { return data; }
                                               var ret = success(data);
                                               if (!isPromiseLike(ret)) {
                                                 error.message = "Task " + key + " did not return a promise.";
                                                 throw error;
                                               }
                                               return ret;
                                             },
                                             /*failure*/function (reason) {
                                               if (!fail) { return $delegate.reject(reason); }
                                               var ret = fail(reason);
                                               if (!isPromiseLike(ret)) {
                                                 error.message = "Fail for task " + key + " did not return a promise.";
                                                 throw error;
                                               }
                                               return ret;
                                             },
                                             notify);
                                         }
                                         prevPromise = nextPromise;
                                       });

                                       return prevPromise || $delegate.when();
                                     }

                                     $delegate.serial = serial;
                                     return $delegate;
                                   }
                                 ]);
            }
          ]);
(function () {
  "use strict";

  angular.module('appToten').config(routeFn);

  routeFn.$inject = ['$stateProvider', '$urlRouterProvider', 'localStorageServiceProvider', 'cfpLoadingBarProvider'];

  function routeFn($stateProvider, $urlRouterProvider, localStorageServiceProvider, cfpLoadingBarProvider) {

    cfpLoadingBarProvider.includeSpinner = false;

    localStorageServiceProvider
      .setPrefix('appToten')
      .setStorageType('sessionStorage');

    $urlRouterProvider.otherwise('/');

    $stateProvider
      .state("erro", {
        url: "/404",
        templateUrl: "./views/404.html"
      })

      .state("home", {
        url: "/home",
        templateUrl: "./views/home.html"
      })

      .state("login", {
        url: "/",
        templateUrl: "./views/login.html",
        controller: "loginController"
      })

      .state("categorias", {
        url: "/categorias",
        templateUrl: "./views/categorias.html",
        controller: "categoriaController"
      })

      .state("carrinho", {
        url: "/meuCarrinho",
        templateUrl: "./views/carrinho.html",
        controller: "carrinhoController"
      })

      .state("cadastro", {
        url: "/cadastro",
        templateUrl: "./views/cadastro.html",
        controller: "cadastroController"
      })

      .state("produtos", {
        url: "/produtos/:categoria",
        templateUrl: "./views/produtos.html",
        controller: "produtosController"
      })

      .state("produto", {
        url: "/produto/:id",
        templateUrl: "./views/produto.html",
        controller: "produtoController"
      })

      .state("pagamento", {
        url: "/pagamento",
        templateUrl: "./views/pagamento.html",
        controller: "pagamentoController"
      })

      .state("finalizacao", {
        url: "/finalizacao",
        templateUrl: "./views/finalizacao.html",
        controller: "pagamentoController"
      })
  }
})(angular);


//# sourceMappingURL=../map/config/configModule.min.js.map
