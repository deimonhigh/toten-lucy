angular
  .module("appToten")
  .factory("loadingInterceptor", loadingInterceptor);

loadingInterceptor.$inject = ['$q', '$rootScope'];

function loadingInterceptor($q, $rootScope) {
  var loadingCount = 0;
  return {
    request: function (config) {
      if (++loadingCount === 1) $rootScope.$broadcast('loading:progress');
      return config || $q.when(config);
    },

    response: function (response) {
      if (--loadingCount === 0) $rootScope.$broadcast('loading:finish');
      return response || $q.when(response);
    },

    responseError: function (response) {
      if (--loadingCount === 0) $rootScope.$broadcast('loading:finish');
      return $q.reject(response);
    }
  };
};
angular
  .module("appToten")
  .factory("autenticacaoInterceptor", [
    'localStorageService', 'config', 'base64Factory', function (localStorageService, config, base64Factory) {
      return {
        request: function (requisicao) {

          try {

            var storage = localStorageService.get('autenticacao');

            if (
              storage == null &&
              ((requisicao.url.indexOf("apigopharma") > -1 && requisicao.url.indexOf('token') == -1) || requisicao.url.indexOf('.html') > -1)
            ) {
              throw "No token"
            }

            var autorizacaoDados = JSON.parse(base64Factory.decode(storage));

            if (autorizacaoDados) {
              if (requisicao.url.indexOf("apigopharma") > -1 && requisicao.url.indexOf('token') == -1) {
                requisicao.headers["Authorization"] = autorizacaoDados.token;
              } else {
                var diferencaMinutos = (new Date(autorizacaoDados.expires) - new Date());

                if (diferencaMinutos <= 0) {
                  location.reload();
                }
              }

            }

            return requisicao;

          }
          catch (e) {
            if (requisicao.url.indexOf("apigopharma") == -1) {
              return requisicao;
            }
          }

        }
      }
    }
  ]);

(function (angular) {
  angular
    .module("appToten")
    .config([
              '$httpProvider',
              function ($httpProvider) {
                $httpProvider.interceptors.push("autenticacaoInterceptor");
                $httpProvider.interceptors.push("loadingInterceptor");
              }
            ]);
})(angular);


angular
  .module("appToten")
  .constant("config", {
    "apiUrl": ""
  });

angular
  .module("appToten")
  .config([
            "$provide",
            function ($provide) {
              $provide.decorator("$q",
                                 [
                                   "$delegate",
                                   function ($delegate) {
                                     //Helper method copied from q.js.
                                     var isPromiseLike = function (obj) { return obj && angular.isFunction(obj.then); }

                                     /*
                                      * @description Execute a collection of tasks serially.  A task is a function that returns a promise
                                      *
                                      * @param {Array.<Function>|Object.<Function>} tasks An array or hash of tasks.  A tasks is a function
                                      *   that returns a promise.  You can also provide a collection of objects with a success tasks, failure task, and/or notify function
                                      * @returns {Promise} Returns a single promise that will be resolved or rejected when the last task
                                      *   has been resolved or rejected.
                                      */
                                     function serial(tasks) {
                                       //Fake a "previous task" for our initial iteration
                                       var prevPromise;
                                       var error = new Error();
                                       angular.forEach(tasks, function (task, key) {
                                         var success = task.success || task;
                                         var fail = task.fail;
                                         var notify = task.notify;
                                         var nextPromise;

                                         //First task
                                         if (!prevPromise) {
                                           nextPromise = success();
                                           if (!isPromiseLike(nextPromise)) {
                                             error.message = "Task " + key + " did not return a promise.";
                                             throw error;
                                           }
                                         } else {
                                           //Wait until the previous promise has resolved or rejected to execute the next task
                                           nextPromise = prevPromise.then(
                                             /*success*/function (data) {
                                               if (!success) { return data; }
                                               var ret = success(data);
                                               if (!isPromiseLike(ret)) {
                                                 error.message = "Task " + key + " did not return a promise.";
                                                 throw error;
                                               }
                                               return ret;
                                             },
                                             /*failure*/function (reason) {
                                               if (!fail) { return $delegate.reject(reason); }
                                               var ret = fail(reason);
                                               if (!isPromiseLike(ret)) {
                                                 error.message = "Fail for task " + key + " did not return a promise.";
                                                 throw error;
                                               }
                                               return ret;
                                             },
                                             notify);
                                         }
                                         prevPromise = nextPromise;
                                       });

                                       return prevPromise || $delegate.when();
                                     }

                                     $delegate.serial = serial;
                                     return $delegate;
                                   }
                                 ]);
            }
          ]);
(function () {
  "use strict";

  angular.module('appToten').config(routeFn);

  routeFn.$inject = ['$stateProvider', '$urlRouterProvider', 'localStorageServiceProvider', 'cfpLoadingBarProvider'];

  function routeFn($stateProvider, $urlRouterProvider, localStorageServiceProvider, cfpLoadingBarProvider) {

    cfpLoadingBarProvider.includeSpinner = false;

    localStorageServiceProvider
      .setPrefix('appToten')
      .setStorageType('localStorage');

    $urlRouterProvider.otherwise('/');

    $stateProvider
      .state("erro", {
        url: "/404",
        templateUrl: "./views/404.html"
      })

      .state("home", {
        url: "/home",
        templateUrl: "./views/home.html",
        controller: "homeController"
      })

      .state("login", {
        url: "/",
        templateUrl: "./views/login.html",
        controller: "loginController"
      })

      .state("categorias", {
        url: "/categorias",
        templateUrl: "./views/categorias.html",
        controller: "loginController"
      })

  }
})(angular);


//# sourceMappingURL=../map/config/configModule.min.js.map
